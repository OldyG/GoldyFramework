/**
 * FileName : {@link DbSource}.java
 * Created : 2017. 4. 10.
 * Author : jeong
 * Summary :
 * Copyright (C) 2017 Goldy Project. All rights reserved.
 * 이 문서의 모든 저작권 및 지적 재산권은 Goldy Project에게 있습니다.
 * 이 문서의 어떠한 부분도 허가 없이 복제 또는 수정 하거나, 전송할 수 없습니다.
 */
package com.goldyframework.db;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.LinkedList;
import java.util.List;

import javax.sql.DataSource;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import com.goldyframework.db.exception.NoSingleDataException;

/**
 * DB 접속에 공통으로 사용되는 클래스
 */
@Component
public class DbSource {

	/**
	 * slf4j Logger
	 *
	 * @author jeong
	 * @since 2017. 5. 22. 오후 9:20:02
	 */
	private static final Logger LOGGER = LoggerFactory.getLogger(DbSource.class);

	/**
	 * 데이터 추출 클래스 DriverManagerDataSource
	 */
	@Autowired
	private DataSource ds;

	/**
	 * DB 연결자
	 */
	private Connection con;

	/**
	 * A table of data representing a database result set, which is usually generated by executing a statement that
	 * queries the database.
	 */
	private ResultSet resultSet;

	/**
	 * An object that represents a precompiled SQL statement.
	 */
	private PreparedStatement stmt;

	/**
	 * {@link DbSource} 클래스의 새 인스턴스를 초기화 합니다.
	 *
	 * @author jeong
	 * @since 2017. 3. 5. 오후 2:01:12
	 */
	public DbSource() {}

	/**
	 * {@link DbSource} 클래스의 새 인스턴스를 초기화 합니다.
	 *
	 * @author jeong
	 * @since 2017. 4. 10. 오후 9:30:15
	 * @param dataSource
	 *            데이터 소스
	 */
	public DbSource(final DataSource dataSource) {
		this.ds = dataSource;
	}

	/**
	 * 쿼리 실행을 알립니다.
	 * 이 선언을 할 경우 반드시 {@link #commit()} 또는 {@link #rollback()}를 선언해야합니다.
	 *
	 * @author jeonghyun.kum
	 * @throws SQLException
	 *             An exception that provides information on a database access error or other errors.
	 * @since 2016. 5. 7. 오후 9:14:40
	 */
	public void begin() throws SQLException {

		this.update("begin work;"); //$NON-NLS-1$
	}

	/**
	 * {@link ResultSet}, {@link PreparedStatement}, {@link Connection}을 닫습니다.
	 *
	 * @author 2017. 6. 18. 오전 11:17:16 jeong
	 * @throws SQLException
	 *             An exception that provides information on a database access error or other errors.
	 */
	private void close() throws SQLException {

		this.closeResultSet();

		this.closePreparedStatement();

		this.closeConnection();
	}

	/**
	 * {@link Connection}을 닫습니다.
	 *
	 * @author 2017. 6. 18. 오전 11:16:37 jeong
	 * @throws SQLException
	 *             An exception that provides information on a database access error or other errors.
	 */
	private void closeConnection() throws SQLException {

		try {
			if (this.con != null) {
				this.con.close();
			}
		} catch (final SQLException e) {
			LOGGER.error("DB Connection을 닫지 못했습니다." + e.getMessage(), e); //$NON-NLS-1$
			throw e;
		}
	}

	/**
	 * {@link PreparedStatement}를 닫습니다.
	 *
	 * @author 2017. 6. 18. 오전 11:18:13 jeong
	 * @throws SQLException
	 *             An exception that provides information on a database access error or other errors.
	 */
	private void closePreparedStatement() throws SQLException {

		try {
			if (this.stmt != null) {
				this.stmt.close();
			}
		} catch (final SQLException e) {
			LOGGER.error("PreparedStatement를 닫지 못했습니다." + e.getMessage(), e); //$NON-NLS-1$
			throw e;
		}
	}

	/**
	 * {@link ResultSet}을 닫습니다.
	 *
	 * @author 2017. 6. 18. 오전 11:17:58 jeong
	 * @throws SQLException
	 *             An exception that provides information on a database access error or other errors.
	 */
	private void closeResultSet() throws SQLException {

		try {
			if (this.resultSet != null) {
				this.resultSet.close();
			}
		} catch (final SQLException e) {
			LOGGER.error("ResultSet을 닫지 못했습니다." + e.getMessage(), e); //$NON-NLS-1$
			throw e;
		}
	}

	/**
	 * 쿼리가 완료됨을 알립니다.
	 * 이 선언을 알리기 전엔 {@link #begin()}을 기준으로 완료됩니다.
	 *
	 * @author jeonghyun.kum
	 * @throws SQLException
	 *             An exception that provides information on a database access error or other errors.
	 * @since 2016. 5. 7. 오후 9:17:31
	 */
	public void commit() throws SQLException {

		this.update("commit;"); //$NON-NLS-1$
	}

	/**
	 * SELECT SQL문에 해당하는 데이터가 존재한지 여부를 반환합니다.
	 *
	 * @author 2017. 6. 18. 오전 11:15:38 jeong
	 * @param sql
	 *            SELECT SQL 문
	 * @return 데이터가 존재하는 경우 true, 아닌경우 false 반환
	 * @throws SQLException
	 *             An exception that provides information on a database access error or other errors.
	 */
	public synchronized boolean exist(final String sql) throws SQLException {

		final Collection<String> list = this.getColumnString(sql);
		return !list.isEmpty();
	}

	/**
	 * 1개의 행을 정수 목록으로 받습니다. (한개 컬럼에 대한 목록)
	 *
	 * @author 2017. 6. 18. 오전 11:15:31 jeong
	 * @param sql
	 *            SELECT SQL 문
	 * @return 정수 리스트
	 * @throws SQLException
	 *             An exception that provides information on a database access error or other errors.
	 */
	public synchronized Collection<Integer> getColumnIntegerList(final String sql) throws SQLException {

		final Collection<String> columnStringList = this.getColumnString(sql);

		final Collection<Integer> returnTarget = new LinkedList<>();
		try {
			for (final String columnString : columnStringList) {
				returnTarget.add(Integer.valueOf(columnString));
			}
		} catch (final NumberFormatException e) {
			throw new SQLException("데이터가 Integer 타입이 아닙니다.", e); //$NON-NLS-1$
		}
		return returnTarget;
	}

	/**
	 * 1개의 행을 문자열 리스트로 반환받습니다.(한개 컬럼에 대한 목록)
	 *
	 * @author 2017. 6. 18. 오전 11:15:32 jeong
	 * @param sql
	 *            SELECT SQL 문
	 * @return 문자열 리스트
	 * @throws SQLException
	 *             An exception that provides information on a database access error or other errors.
	 */
	public synchronized Collection<String> getColumnString(final String sql) throws SQLException {

		final Collection<String> defines = new ArrayList<>();
		try {
			@SuppressWarnings("resource")
			final ResultSet rs = this.querySQL(sql);

			while (rs.next()) {
				final String define;
				if (rs.getString(1) == null) {
					define = ""; //$NON-NLS-1$
				} else {
					define = rs.getString(1);
				}
				defines.add(define.trim());
			}
		} finally {
			this.close();
		}

		return defines;
	}

	/**
	 * 정수 1개를 반환받습니다.
	 * SQL 문은 반드시 1개의 결과만 받을 수 있는 문법이어야합니다.
	 *
	 * @author 2017. 6. 18. 오전 11:15:38 jeong
	 * @param sql
	 *            SELECT SQL 문
	 * @return 정수 1개
	 * @throws SQLException
	 *             An exception that provides information on a database access error or other errors.
	 * @throws
	 * 			NoSingleDataException
	 *             만약 결과가 1개가 아닌 경우 발생합니다.
	 */
	public synchronized int getInteger(final String sql) throws SQLException, NoSingleDataException {

		final List<Integer> values = new ArrayList<>(this.queryForIntegerList(sql));
		if (values.isEmpty() || (values.size() > 2)) {
			throw new NoSingleDataException();
		}
		return values.get(0).intValue();
	}

	/**
	 * 한개의 열을 정수로 받습니다.
	 * 여러 줄일 경우 첫번째 열만 반환받습니다.
	 * 만약 Int Casting이 불가능한경우 예외가 발생합니다.
	 *
	 * @author 2017. 6. 18. 오전 11:15:35 jeong
	 * @param sql
	 *            SELECT SQL 문
	 * @return Integer 리스트
	 * @throws SQLException
	 *             An exception that provides information on a database access error or other errors.
	 */
	public synchronized Collection<Integer> getRowIntegerList(final String sql) throws SQLException {

		final Collection<String> rowStringList = this.getRowString(sql);

		final Collection<Integer> returnTarget = new LinkedList<>();
		try {
			for (final String rowString : rowStringList) {
				returnTarget.add(Integer.valueOf(rowString));
			}
		} catch (final NumberFormatException e) {
			throw new SQLException("데이터가 Integer 타입이 아닙니다.", e); //$NON-NLS-1$
		}

		return returnTarget;
	}

	/**
	 * 한개의 열을 문자열로 받습니다.
	 * 여러 줄일 경우 첫번째 열만 반환받습니다.
	 *
	 * @author 2017. 6. 18. 오전 11:15:37 jeong
	 * @param sql
	 *            SELECT SQL 문
	 * @return 열 리스트
	 * @throws SQLException
	 *             An exception that provides information on a database access error or other errors.
	 */
	public synchronized Collection<String> getRowString(final String sql) throws SQLException {

		final Collection<Collection<String>> arrayList = this.getTable(sql);

		Collection<String> array = new LinkedList<>();
		if (arrayList.isEmpty() == false) {
			array = arrayList.iterator().next();
		}

		return array;
	}

	/**
	 * 문자열 1개를 반환받습니다.
	 * SQL 문은 반드시 1개의 결과만 받을 수 있는 문법이어야합니다.
	 *
	 * @author 2017. 6. 18. 오전 11:15:38 jeong
	 * @param sql
	 *            SELECT SQL 문
	 * @return 문자열 1개
	 * @throws SQLException
	 *             An exception that provides information on a database access error or other errors.
	 * @throws
	 * 			NoSingleDataException
	 *             만약 결과가 1개가 아닌 경우 발생합니다.
	 */
	public synchronized String getString(final String sql) throws SQLException, NoSingleDataException {

		final List<String> results = new ArrayList<>(this.getColumnString(sql));

		if (results.isEmpty() || (results.size() > 2)) {
			throw new NoSingleDataException();
		}

		return results.get(0);
	}

	/**
	 * 테이블을 반환받습니다.
	 *
	 * @author 2017. 6. 18. 오전 11:15:39 jeong
	 * @param sql
	 *            SELECT SQL 문
	 * @return 테이블을 받습니다.
	 * @throws SQLException
	 *             An exception that provides information on a database access error or other errors.
	 */
	public synchronized Collection<Collection<String>> getTable(final String sql) throws SQLException {

		final Collection<Collection<String>> defines = new ArrayList<>();
		try {

			@SuppressWarnings("resource")
			final ResultSet rs = this.querySQL(sql);
			final int size = rs.getMetaData().getColumnCount();
			while (rs.next()) {

				final LinkedList<String> tt = new LinkedList<>();

				for (int i = 0; i < size; i++) {
					tt.add(rs.getString(i + 1));
				}

				defines.add(tt);
			}
		} finally {
			this.close();
		}

		return defines;
	}

	/**
	 * int 리스트를 반환받습니다.
	 *
	 * @author 2017. 6. 18. 오전 11:15:41 jeong
	 * @param sql
	 *            SELECT SQL 문
	 * @return int 리스트
	 * @throws SQLException
	 *             An exception that provides information on a database access error or other errors.
	 */
	public synchronized Collection<Integer> queryForIntegerList(final String sql) throws SQLException {

		final Collection<Integer> results = new ArrayList<>();
		try {
			@SuppressWarnings("resource")
			final ResultSet rs = this.querySQL(sql);

			while (rs.next()) {
				final int value = rs.getInt(1);
				results.add(Integer.valueOf(value));
			}
		} finally {
			this.close();
		}

		return results;
	}

	/**
	 * Database에 SQL문을 보낸 뒤 {@link ResultSet}을 반환받습니다.
	 *
	 * @author 2017. 6. 18. 오전 11:15:43 jeong
	 * @param sql
	 *            SELECT SQL 문
	 * @return {@link ResultSet}
	 * @throws SQLException
	 *             An exception that provides information on a database access error or other errors.
	 */
	private synchronized ResultSet querySQL(final String sql) throws SQLException {

		LOGGER.trace(sql);
		try {
			this.con = this.ds.getConnection();
			this.stmt = this.con.prepareStatement(sql);
			this.resultSet = this.stmt.executeQuery();

			return this.resultSet;
		} catch (final SQLException e) {
			LOGGER.error("Database 쿼리 중 오류 발생", e); //$NON-NLS-1$
			throw e;
		}
	}

	/**
	 * update , insert , delete 할때 결과값을 받아오기 위해 만듬
	 *
	 * @author 2017. 6. 18. 오전 11:15:44 jeong
	 * @param sql
	 *            결과가 필요없는 문법 (update, insert, delete 등)
	 * @return either (1) the row count for SQL Data Manipulation Language (DML) statements or (2) 0 for SQL statements
	 *         that return nothing
	 * @throws SQLException
	 *             An exception that provides information on a database access error or other errors.
	 */
	private int queryUpdateSQL(final String sql) throws SQLException {

		LOGGER.trace(sql);
		this.con = this.ds.getConnection();
		this.stmt = this.con.prepareStatement(sql);

		return this.stmt.executeUpdate();
	}

	/**
	 * 쿼리가 취소됨을 알립니다.
	 * 이는 {@link #begin()}이 후 오류가 발생하였을때 사용합니다.
	 *
	 * @author jeonghyun.kum
	 * @throws SQLException
	 *             An exception that provides information on a database access error or other errors.
	 * @since 2016. 5. 7. 오후 9:18:24
	 */
	public void rollback() throws SQLException {

		this.update("rollback work;"); //$NON-NLS-1$
	}

	/**
	 * update , insert , delete 할때 결과값을 받아오기 위해 만듦
	 *
	 * @author 2017. 6. 18. 오전 11:15:49 jeong
	 * @param sql
	 *            결과가 필요없는 문법 (update, insert, delete 등)
	 * @throws SQLException
	 *             An exception that provides information on a database access error or other errors.
	 */
	public synchronized void update(final String sql) throws SQLException {

		try {
			final int result = this.queryUpdateSQL(sql);
			if ((result > 0) == false) {
				final Collection<String> notList = Arrays.asList("commit;", "begin work;", "rollback work;"); //$NON-NLS-1$//$NON-NLS-2$//$NON-NLS-3$
				if (notList.contains(sql) == false) {
					throw new SQLException("Fail for " + sql); //$NON-NLS-1$
				}
			}
		} finally {
			this.close();
		}
	}

}
